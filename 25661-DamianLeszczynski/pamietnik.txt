Laboratorium 1 (05.03.22)

Na ćwiczeniach instalowaliśmy system operacyjny (debiana), czyli wirtualną maszynę. Używaliśmy do tego programu VirtualBox. 

VirtualBox- to program do wirtualizacji systemów operacyjnych. Pozwala na uruchamianie wirtualnych komputerów, gdzie można instalować i uruchamiać inne systemy operacyjne np. Linuxa na Windows.
Wirtuale maszyny można łatwo przenosić pomiędzy różnymi hostami, kopiując ich obraz dysków. 

Jak takowego debiana zainstalować na swoim komputerze? 

Jak już mamy zainstalowanego VisrtualBoxa, musimy pobrać system operacyjny ( w naszym przypadku jest to Debian), więc wchodzimy na strone "www.debian.org"" i klikamy pobieranie.
Jak już sciągneliśmy Debiana odpalamy VirtualBoxa, i klikamy Globalne ustawienia. 

Otwiera się okienko z 8 zakładkami:
-Ogólne ( Wybieramy tam folder, w którym będą miesciły się nasze wirtualne maszyny);
-Wejście ( Tam ustawiamy skróty klawiszowe potrzebne do sterowania systemem);
-Aktualizacja (Ustawienia dotyczące aktualizacji);
-Jezyk ( Ustawiamy język );
-Sieć ( Podłączamy karty sieciowe);
-Rozszerzenia (Wybieramy roszerzenia do systemu );
-Proxy (Ustawienia i konfiguracja hostów);

Ustawiamy w zakładce Ogólne, domyśliny folder maszyn wirtualnych. Kikamy w w ścierzkę domyślną potem "Inny" i wybieramy folder docelowy.
Poniżej widnieje opcja, biblioteka uwierzytelniania dla VRDP ( VirtualBox Remote Desktop Protocol). 
Umożliwia ona zdalne wyświetlanie danych wyjściowych okna maszyny wirtualnej na dowolnych innym komputzerze i sterowanie maszyną wirtualną stamtąd, tak jakby była uruchomiona na maszynie zdanlnej.
Tutaj zostawiamy jak jest, czyli nic nie zmieniamy.

Następnie, klikamy niebieską ikonę "Nowa", wyskakuje nam okienko, w którym wyskakują następujące opcję: 
-Name: (Wybieramy nazwę naszej maszynki);
-Machinę Folder: ( Folder, w którym nasza maszyna ma być zainstalowana, ale ustawialiśmy już to wcześniej w globalnych ustawieniach.);
-Typ: ( System na jakim będzie postawiona nasza maszyna, w naszym przypadku jest to Linux );
-Wersja: (Wersja maszyny w naszym przypadku Debian(64-bit);

Klikamy dalej, wyskakuję drugie okienko, w którym wybieramy rozmiar pamięci RAM jaki chcemy wykorzystać w naszej maszynie.
1023 MB wystarczy w zupełności, ale ja profilaktycznie wybieram dwukrotność tego, czyli 2048 MB.

Klikamy dalej, wyskakuję trzecie okienko zatytułowane "Dysk twardy".Mamy do wyboru 3 opcję:
-Nie dodawaj wirtualnego dysku twardego;
-Stwórz wirtualny dysk twardy (Tworzymy wirtualny dysk twardy, ustawiając jego parametry od początku, i tą opcję wybieramy);
-Użyj istniejącego pliku wirtualnego dysku twardego (Wybieramy tą opcję chcemy skorzystać z utworzonego już dysku wirtualnego (plik VDI));

Wybierając drugą opcję, klikamy utwórzy.Wyskoczyło nam czwarte okienko z trzema ocjami do wyboru:

-VDI(VirtualBox disk Image) - Standardowe natywne rozwiązanie VirtualBoxa (najlepsze działanie na naszej maszynie);
-VHD(Virtual Hard Disk) - Rozwiązanie firmy Microsoft przeznaczony na maszyny HyperV;
-VMDK(Virtual Machine Disk) - Rozwiązanie Firmy VMware przeznaczone na maszymy VMware Workstation Player;

Wybieramy pierwszą opcję, wciskamy dalej i wyskakuje nam okienko piąte, w którym mamy 2 opcję:

-Dynamicznie przydzielany (Ustawiamy maksymalną pojemność do jakiej dysk będzie mógł się rozszerzyć w miare potrzeb);
-Stały rozmiar (Rozmiar dysku jest ustalony z góry);

Wybieramy opcję pierwszą, wciskamy dalej.Wyskakuję nam okienko "Lokalizacja i rozmiar.

-W lokalizacji ustawiamy gdzie nasz dysk ma przechowywać dane;
-Na suwaczku ustawiamy pojemność twardego dysku ( w naszym przyapdku jest to 8GB, zostawiamy bo to jest tylko maszynka testowa);

Wsiskamy utwórz, Stworzyliśmy maszynkę , która jest wyłączona. Możemy ją otpalić na 3 różne sposoby:

-Zwykły start ( maszyna po porstu się uruchomi);
-Bezałogowy start ( Maszyna odpala się w tle, ale okienko nie wyskakuję, użyteczne kiedy na maszynie jest postawiony serwer, który tylko musimy włączyć);
-Oddzielny start( Maszyna odpala się w w tle i oknie,natomiast po zamknięci okna maszyna dalej działa;

Ale zanim uruchomimy maszynę, wchodzimy w żółtą ikonke z napisem "Ustawienia".Wyskakuję okienko z następującymi zakładkami:

-Ogólne;
-System ( w kolejności bootwania odznaczymy floppy);
-Ekran;
-Pamięć ( w tej zakładcę klikamy "dodaj napęd optyczny".Klikamy dodaj i wybieramy nasz system, który pobraliśmy);
-Dźwięk ( odznaczymy "endable Audio Output");
-Sieć;
-Porty szeregowe;
-USB;
-Udostępniane foldery;
-Interfejs użytkownika;

Zatwierdzamy nasze ustawienia i odpalamy naszą maszynę.

Po dopaleniu wyskakuję nam okienko, zawierające informacje na temat przechwytywania naszego kursora.
Po zaakceptowaniu jeżeli chcemy poruszać myszką na naszym komputerze musimy nacisnąc prawy CTRL.

Klikamy CTRL + R (resetowanie maszyny), następnie ENTER potwierdzający komunikat i musimy szybko po tym kliknąc F12(Boot Menu). Wybieramy opcję numer jeden (Bootowanie naszego wirtualnego dysku).

Wyskoczyło nam menu "Debian GNU/Linux installer menu (BIOS mode)" z następującymi opcjami do wyboru:

-Graphical install (Instalacja graficzna, czyli okienkowa);
-Install(zwykła instalacja, którą wybieramy);
-Advanced options:
	-Back.. (Klikamy to kiedy chcemy cofnąć do porzedniej strony, można też to zrobić BACKSPACE albo ESC, Chociaż nie zawsze bo w róznych przypadkach możemy po prostu wyłączyć maszynę);
	-Graphical expert install (Graficzna instalacja ekspercka);
	-Graphical rescue mode (Graficzny tryp odzyskiwania);
	-Graphical automated install (Graficzna instalacja automatyczna);
	-Expert install (Ekspercka instalacja testowa);
	-Rescue mode (Tryp odzyskiwania tekstowy);
	-Automated install (Automatyczna instalacja tekstowa);
	-Speech-enable advanced option (Zaawansowane ustawienia syntezatora mowy);
		-Expert speech install (kspercka instalacja tekstowa z syntezatorem);
		-Rescue speech mode (Tryb odzyskiwania tekstowy z syntezatorem);
		-Rescue speech install (Instalacja trybu odzyskiwania tekstowego z syntezatorem);
-Accessible dark contrast installer menu (Instalacja menu w ciemny kontrascie);
-Help (Wyświetlenie menu pommocy do instalatora);
-Install with speecj synthesis (Instalacja z syntezatorem mowy);

Wybieramy opcję install,pojawią nam się następujące okienka:

-Wybór języka systemu (Wybieramy Angielski);
-Wybieramy lokalizacjęw jakiej się znajdujemy, będzie to informacja potrzebna do łączenia się z serwerami (other/Europe/Poland);
-Wybieramy tryp kodowania znaków (United States - en_US.UTF-8);
-Wybieramy mape klawiszy (American English);
(Wybieramy wszystko w języku Angielskim, ponieważ jest on językiem uniwersalnym. Wybór tego języka bardzo ułatwia pracę)

System przeinstalował dane odnośnie języka i wyświetliło się następne okienko:

-Ustawienie nazwy hosta (pod tą nazwą nasz komputer będzie winiał w sieci);
-Ustawiamy nazwę naszej domeny;
-Ustawiamy hasło do uprawnień ROOT (Czyli najwyższe uprawnienia administracyjnę naszego systemu);
-Potwierdzenie hasła;
-Ustawiamy imię i nazwisko użytkownika systemu;
-Ustawienia loginu konta;
-Ustawienie hasła konta;
-Potwierdzenia hasła;

System przeinstalował dane odnośnie nazw i haseł i wyświetliło się następujące okienko:

-Guided - use emtire disk ( Przypisanie jednej partycji na całym dysku);
-Guided - use entire disk and set up LVM (Przypisanie jendej parcyji i ustawienie LVM);
(LVm - Logical Bolume Menager, Jest to elastyczny mechanizm do zarządzanie przestrzenią dyskową);
-Guided - use entire disk and set up encrypted LVM (Przypisanie jendej parcyji i ustawienie szyfrowanego LVM);
-Manual (Ręczne partycjonowanie dysków)- Wybieramy tą opcję;

Wyskoczyło okienko z pięcioma opcjami do wyboru:

-Guided partitioning (Partycjonowanie dysków z "Przewodnikiem");
-Configure iSCSI volumes - Konfiguracja woluminów ISCII (Indian Script Code For Information Interchange, to schemat kodowania reprezentujący różne systemy pisania w Indiach.);
-SCSI3 (0,0,0) (sda) - 8.6 GB ATA VBOX HARDSIK (Są to nasze wszystkie partycję dysków;
-Undo changes to partitions (Cofanie zmian);
-Finish  partitioning and write changes to disk (Kończenie i zapisywanie partycjonowania na dysku);

Wybieramy opcje trzecią, wyskakuję okienko z pytaniem czy chcemy stworzyć nową partycję na naszym urządzeniu (Wybieramy YES).
 		
Wyskakuję nam podobnę okienko, poszerzone o cztery opcję:

-Configure Sofware Raid (konfiguracja RAID,czyli nadmiarowa macierz niezależnych dysków, jest to sposób na wykorzystanie w systemie komputerowym kilku dysków twardych, dzięki któremu dyski te współpracują ze sobą.);
-Configure the Logical Volume Manager (Konfiguracja menadżera woluminów logicznych);
-Configure encrypted manager (Konfiguracja menadżera Szyfrowania);
-pri/log 8.6 GB FREE SPACE (Wybieramy tą opcję);

Wyskakuje okienko z trzema opcjami:

-Create a new partition ( Tworzenie nowej partycji) -Wybieramy tą opcję;
-Automatically partition the free space ( Automatyczne tworzenie partycji na wolnym miejscu dysku);
-Show Cylinder/Head/Sector information (Pokazuje informacje na temat naszego dysku);

Wyskakuję okienko z rozmiarem partycji dysku ( Wyskakuję nam 8.6 GB musimy wybrać mniejszy rozmiar, żeby wystarczyło miejsca na pamięć logiczną).

Następnie wyskakuję nam okienko odnośnie typu partycji(Logiczna czy podstawowa).
( Partycja podstawowa to partycja rozruchowa zawierająca system operacyjny komputera, natomiast partycja logiczna to partycja, której nie można uruchomić.)

Wybieramy opcje "Pirmary",a następnie opcję "Beginning" (czyli ustawiamy tą partycję na początku.)

Wyskakuję nam okieno zatytułowane "Ustawienia partycji" i 9 następujących opcji:

-Use as: (Używaj jako domyślnie system plików ext4,rosrzerzony system plików);
-Mount point: (punkt montowania, katalogi jako część główneego systemu plików.);
-Mount options: (opcję montowania);
-Label (etykieta, właściwosć, w którym jest sformatowana partycja lub cały dysk);
-Reserved blocks - (Zarezerwowane bloki,niewielka część dysku jest rezerwowana dla uprzywilejowanego procesu.);
-Typical usage - (typowe zastosowanie);
-Bootable flag - (flaga startowa, wskazanie gdzię znajduję się program ładujący);
-Delete the partition (Usunięcie partycji);
-Done setting up the partition (Wybieramy tą opcję.);

Utworzyliśmy partycję podstawową.Musimy stworzyć teraz partycję logiczną.Robi się to prawie tak samo jak poprzednią.

-Wybieramy znowu FREE SPACE;
-Create a nwe partition;
-Ustawiamy rozmiar partycji;
-Ustawiamy Logical (ponieważ będzie to partycja logiczna);

Wyskakuję nam okienko, klikamy "Use as:", w którym wyskakują nam następujące opcję:

-Ext4 journaling file system (Następca ext3. Obecnie najpopularniejszy system plików dla systemów Linuxa.);
-Ext3 journaling file system (System plików oparty na ext2. Domyśdlny dla większości systemów Linux);
-Ext2 file system (drugi rozszerzony system plików dla systemu Linux. Rozpoznanie uszkoczeń systemu następuje podczas startu.); 
-btrfs journaling file system (system plików copy-to-copy w stylu logowania. Zamiast zapisywać od razu w bloku są one najpierw tworzone w nowej lokalizacji, a następnie łączy się je.);
-JFS journaling file system (64bitowy system plików z księgowaniem opracowany przez IBM. Jest wykorzystywany w systemach AIX);  
-XFS journaling file system (64bitowy system plików z księgowaniem przeznaczony głównie do systemu IRIX. Pozwala na obsługę dużych dysków twardych);
-FAT16 file system (System plików posługujący się 16-bitowym adresowaniem. Pierwsze komputery działąjące na systemie DOS miały architekturę 16 bitową);
-FAT32 file system (System plików użyty pierwszy raz w windows 95);
-swap area - obszar wymiany (Jest to tzw. fałszywa pamięć ram. która znajduje się na dysku.)
-physical volume for encryption (Fizyczny wolumin do szyfrowania);
-physical volume for RAID (Fizyczny wolumin dla Raida);
-physical volume for LVM  (Fizyczny wolumin dla LVM);
-do not use the partition (Nie używaj partycji);
 
Wybieramy opcję "swap area",następnie zapisujemy wszsytkie zmiany.

Instalator ładuje dane odnośnie partycji,następnie wyskakuję nam okienko z informacją dotyczącą skanowania innych nośników(Wciskamy nie);

Wyskakuję okienko, instalator pyta skąd chcemy pobierać lustrzaną kobię debiana. Wybieramy (Poland);
a następnie serwer, z którego chcemy pobrać, czyli(ftp.task.gda.pl);
wyskakują ustawienia serwera proxy(Nie wpisujemy nic);
po przełądowaniu systemu wyskakuje okienko odnośnie ankiety (wiadomo opcja "nie" :) );

w następnym okienku (Task sear), wyskakują nam opcje dotyczące oprogramowania, które dodatkowo chcemy zainstalować.

-GNOME (Graficzne środowisko użytkownika oparte na systemie X Window System.);
-Xfce (Środowisko graficzne dla systemów uniksowych, początkowo wzorowane na CDE.);
-Gnome Flashback (To wolne środowisko graficzne typu open source dla systemów operacyjnych Linux.);
-KDE Plasma (Środowisko graficzne zrealizowane jako wolne oprogramowanie dla systemów operacyjnych Unix i GNU/Linux.););
-Cinnamon (Czyli powłoka graficzna dla środowiska GNOME.);
-MATE (Środowisko które powstało po krytyce na środowisko Gnome. Jego zaletami jest to, że działa w trybie 2D oraz posiada mniejsze sprzętowe wymagania.);
-LXDE (Lightweight X11 Desktop Environment, Środowisko dla systemów operacyjnych Linux.);
-LXQt (Środowisko połączone z dwóch projektów.(LXDE-QT i Razor-qt));
-web server (Oprogramowanie umożliwiające nam postawienie serwera internetowego na naszej wirtualnej maszynie.);
-SSH server (Instalacja protokołu komunikacyjnego służącego w Sieciach TCP/IP. Służy między innymi do zdalnego łączenia się terminalowego z komputerami.);
-standard system utilities (Instalacja standardowych narzędzi systemowych.);


Po wybraniu naszego obrogramowania wyskakuje nam okienko z pytaniem.Czy chcemy na głównej partycji zainstalować GRUB boot loader.
(GRUB boot loader -Program rozruchowy służy do uruchamiania różnych systemów operacyjnych,
 np. Linux, FreeBSD, Windows, DOS i potrafi odczytać wiele rodzajów systemów plików, np. ext2, ext3, ext4, MINIX, FAT, NTFS, FFS, ReiserFS, XFS i JFS.)
Klikamy tak, następnie program pyta nas na jakim dysku Grub ma być zainstalowany.


Finalnie wyskakuje nam okno z informacją o zakończonej instalacji, maszyna jest gotowa do użytkowania. 


Dodatkowe inforamje: 

Zalecana struktura partycji w naszym systemie:

/home - tutaj znajdują sie profile użytkowników;
/var - tutaj znajdują sie logi;
/boot - folder odpowiedzialny za start systemu; 
/swap - pamięć wirtualna;
/user - dane użytkownika;

Dysk dzieli się na partycję ponieważ to ułatwiwia naprawianie ewentualnych usterek. Mianowicie jeżli jest problem z dyskiem nie tracimy wszystkich danych. 

Docker - maszyna wirtualna ns pojedyńczy proces.


Krótkie streszczenie tego coc możemy znaleść na stronie (https://www.debian.org/distrib/)

Są tam różne sposoby pozyskania anszego systemu Debian:

1. Możemy po prostu pobrać plik iso na dwa sposoby:
	-Mały plik obrazu: może być pobrany szybko i powinien być nagrany na dysku wymiennym. 
	 Aby z niego skorzystać potrzebujesz maszyny z połączeniem internetowym.
	-Większy kompletny plik obrazu : zawiera więcej pakietów, ułatwiając instalację na maszynie bez połączenia internetowego.

2. Możemy kupić zestaw płyt Cd lub dvd od jednego z dystrybutorów płyt z debianem, mamy wtedy fizyczną kopie systemu.
	
	Oto podstawowe zalety zestawu płyt:
	 -Instalacja z płyt jest łatwiejsza.
	 -Można zainstalować z nich system na maszynach nie podłączonych do internetu.
	 -Można zainstalować Debiana na dowolnej liczbie maszyn bez potrzeby pobierania pakietów z internetu.
	 -Płyta CD może przydać się do ratowania systemu w razie jego uszkodzenia.
3.Kupienie komputera z preinstalowanym Debian. 
	he?... 
4.Można użyć obrazu Debiana dla chmury.
	Oficjalny obraz do użycia w chmurze, zbudowany przez zespół ds. chmury, może być użyty z:
	 -Dostawcą OpenStack w formacie qcow2 lub raw.
	 -Amazon EC2, zarówno jako obraz maszyny oraz przez AWS Marketplace.
	 -Microsoft Azure, Azure Marketplace.
5.Debian live.
 	Możesz wypróbować Debiana uruchamiając system live z płyty CD, DVD lub napędu USB, bez instalowania żadnych plików w komputerze. 
	Jeśli się zdecydujesz, możesz uruchomić zawarty instalator. 



Laboratorium 2

Na dzisiejszych ćwiczeniach rozmawialiśmy o pisaniu skryptów i wyjaśniliśmy sobie czym, tak właściwie jest bash.

Bash, to nic innego jak powłoka systemowa (Swojego rodzaju łącznik między komputerem jako maszyną, a użytkownikiem), 
pozwalająca na komunikację w trybie tekstowym. Jest to powłoka napisana typowo pod Linuxa, powłoka na Windowsa to np. PowerShell.

Skrypty – programy napisane w językach skryptowych, przeznaczone do wykonywania w specjalnych środowiskach uruchomieniowych automatyzujących wykonywanie zadań.(Wikipedia).
		W totalnym uproszczeniu skrypt to plik tekstowy,który jest instrukcją/programem/algorytmem.

Omawialiśmy podstawy skryptowania, na powłoce Linuksa w Bashu.Żeby z takowej skorzystać trzeba sciągnąć jakiś interpreter, może to być: git bash, cmder,	
(możemy sciągnąć jakąs maszynkę z Linuskem taką jak debian albo ubuntu). My natomiast korzystaliśmy z servera uczelnianego "Szuflandii".
Żeby dostać się do serwera, trzeba pobrać PuTTY (bezpłatny program będący klientem usług TELNET, SSH i rlogin), w którym ustawiamy hostname lub ip (sXXXXX@szuflandia.pjwstk.edu.pl).
Jak się połączymy wpisujemy hasło do konta i mamy dostęp do serwera. 

Zaczynająć od początku jak napisać swój pierwszy skrypt.Musimy najpierw odpalić jakiś edytor tekstu w terminalu(np nano, albo vim).Nano jest dość prymitywnym edytorem,
natomiast Vim jest nieco bardziej zaawansowany co za tym idzie trzeba nauczyć się z niego korzystać,ale jest też bardziej pomocny np. koloruję składnie i jest po prostu wygodniejszy.

Pierwsza linia kodu to tak zwany shebang (#!/bin/bash), jest to linijka, która mówi w jakim interpreterze skryp ma się odpalić, jeżeli skryp będzie napisany w bashu i nie wstawimy shebanga
to nic się złego nie stanie, ponieważ skrypt domyślnie odpali się w bashu, ale jak skryp będzie napisany np w javie, albo w pythonie, to interpreter, nie zrozumie co do niego mówimy. 

Piszemy swój pierwszy skrypt ( odpalamy nano, ponieważ jeszcze nie umiem korzystać z vima):



#!/bin/bash

# Skrypt wykorzystuje zaawansowane funkcje       <-- Każdy skrypt może zawierać komentarz (zaczyna się od # interpreter tego nie czyta)
# systemu do tego, aby narysować króliczka:
echo -e "    \e[m(\\_/)"
echo -e "   (=\e[33m'\e[31m.\e[33m'\e[0m=)"
										 <--Na końcu, każdego skrypu trzeba zapobiegawczo wcisnąć ENTER, ponieważ interpreter nie przeczyta pstatniej linii. 

Wciskamy F2 nano zapyta nas czy chcemy zapisać bufor, wciskamy tak i nadajemy nazwe swojego pliku (kroliczek.sh - na końcu musi byc .sh wtedy interpreter będzie traktował to jako skrypt, 
a nie zwykły plik tekstowy).
   
Czas uruchomić nasz skrypt.Robimy to w następujący sposób ./kroliczek.sh, ale w konsoli zamiast króliczka wyskakuję błąd o braku dostępu.Stało się tak ,ponieważ nie nadaliśmy skryptowi bitu wykonywalności.
Robimy to za pomocą komędy chmod ...,ale jest jeszcze inny sposób.Jest możliwość odpalenia skryptu bez nadawania upranień robi się to w następujący sposób: bash kroliczek.sh.
Skrypt drukuje nam króliczka. 
   
    (\_/)
   (='.'=)

*Różnica między prawami, a uprawnieniamy. W Linuksie nadaję się tylko uprawnienia, w Windowsie natomiast istnieją oba te przypadki. 

Oprócz, tego jak napisać skrypt od podstaw, mówiliśmy też o zmiennych powłokach. 
Zmienna powłoka, służą do przechowywania wartości.Działa to na podobnej zasadzie jak w przypadku programowania. jest zmienna musimy ją nazwać określić typ są zmienne lokalne i globalne i tak dalej.
Tutaj tak samo jak w programowaniu,żeby przypisać jakąś wartość do zmiennej trzeba ją nazwać użyć znaku (=), ale nie trzeba deklarować typu zmiennej, ponieważ system zrobi to automatycznie.

ZM=moja_zmienna 

Jeżeli chodzi o nazywanie zmiennej mamy trzy sposoby, żeby to zrobić:

-Poprostu wpisanie nazwy tak jak wyżej z tym, że nie można wstawić spacji; 
-w " " nawiasach z tym, że jak będziemy mieli jakieś znaki specjalne interpreter przeczyta to jako wartości;
-w ' ' nawiasach pojedyńczych, możemy napisać co nam się podoba. Interpreter przeczyta to po prostu jako napis;

*Nie używa się source'owania w uruchamianiu skryptu, ponieważ nadpisuje funckja (artefakt,efekt uboczny)Source, używa się do doładowania funkcji.

Wiemy jak stworzyć funkcję, natomiast, żeby się jej pozbyć czyli po porstu ją usunąc używamy komendy "unset", czyli unset <nazwa_zmiennej>.

Żeby wyświetlić naszą zmienną używamy następującej komendy: echo $ZM, wtedy konsola wyświetli nam to co przypisaliśmy do "ZM", czyli w naszym przypadku jest to napis "moja_zmienna".
Dolar $ przed zmienną podajęmy kiedy interesuje nas sama wartość (odnosimy się do jej wartości).

np:
-unset ZM usuwamy "całość" zmiennej  
-echo $ZM wyświetlamy "środek" zmiennej

Dziedziczenie: 

Jak już wspomniałem zmienne mogą znajdować się tylko w danej powłocę (zmienne lokalne) lub mogą znajdować się na wszystkich powłokach (zmienne globalne).
Jak przypisujemy daną wartość czyli np zm=3 to ustalamy wartość 3 dla zm na danej powłoce natomiast, żeby zrobić to lokalnie robimy to na dwa sposoby:

-Tworzym zmienną następnie używamy komendy export i przypisujemy ją do każdej powłoki np:
	
	ZM=3 
	export ZM 

-Tworzymy zmienną odrazu przypisując ją do każdej powłoki:

	export ZM=3 

*Poruszanie się po powłokach jest możliwe za pomocą dwóch komend bash i exit, bash skaczemy na kolejną powłoke, exit cofamy się na poprzednią.
 
do usuwania exportowanych wartości istnieją dwa sposoby: 

-export -n zm <-- na powłoce, na której powstała zmienna wpisanie tej komendy usuwa tą wartość na wszystkich powłokach oprócz aktualnej.
-unset zm <-- wpisane na powłoce powstałej usuwa zmienną na wszystkich powłokach oraz na aktualnej, z tym że jak usuniemy na innej powłocę niż na powłoce "matce"
			to zmienna usuwa się tylko na tej powłoce na której ją usunuliśmy a nie na pozostałych( XD ). 

Odczytywanie zmiennych odbywa się na dwa sposoby:

-$Zmienna
-${Zmienna} <-- Przydatne przy kontaminancji "Łączeniu napisów"


Zmienne przydatne do skryptu:

-$? <----- Kod zakończonenia ostatniego procesu, jeżeli wszystko przebiegło bez błędów echo $? wyświetli nam 0;
-$$ <----- Pokazuje nam numer procesu; 
-$! <----- Numer ostatniego uruchomionego procesu;
-$0 <----- Ściężka i sposób uruchomienia skryptu, po odpaleniu kroliczek.sh wpisując echo $0 wyświetla bash; 
-$1,$2,<-- kolejne argumenty skryptu 												(skopiowane z prazentacji)
-$1,$2,<-- kolejne argumenty skryptu												(skopiowane z prazentacji)
-$# <----- ilość argumentów przekazanych do skryptu									(skopiowane z prazentacji)
-$*,$@<--- wszystkie argumenty skryptu. Ale obie zmienne różnią się trochę. Kiedy?		(skopiowane z prazentacji)

Do zmiennej można przypisać wywołanie komendy np:

-ZM=$(echo witaj) <-- sposób starszy trochę wolniejszy, ale działa na wszystkich wersjach;  
-ZM='echo witaj' ,<-- sposób nowszy krótsza składnia, ale może nie działać na wszystkich oprogramowaniach;

Wniosek jest taki, że obie te komendy robią to samo czyli przypisują do wartości zmiennej jakąs komende 
potem po wpisaniu echo $ZM konsola wypluje nam napis witaj w oby dwóch przypadkach. 

Kilka przykładowych zmiennych(dodając echo $...):

-PATH <----- Zemianna zawierająca liczbe scieżek do katalogu; 
-RANDOM <--- Generator losowych liczb, nie najlepszy, ale jest;
-PWD <------ Wyświetla aktualną scieżkę, w której się znajdujemy;
-USER <----- Wyświetla nasz login;
-HOSTNAME <- Wyświetla nazwę hosta;
-OSTYPE <--- Wyświetla nazwę systemu operacyjnego; 

Bash oferuje nam również operację na ciągach znaków, za pomocą (( )), możemy  dokonywać prostych obliczeń np:

-echo $((2+2))
	wyświetla 4 
-X=5
 echo $((2*X))
	wyświetla 10 

Operację na ciągach znaków (skopiowane z prezezentacji): 

${#TEKST} - długość ciągu znaków ( po przypisaniu tekstu do wartości TEKST); 
${TEKST:p} - podciąg rozpoczynający się od znaku o indeksie p. (zamiast p wstawiamy liczbe od której nasz ciąg ma się zacząc jeżeli mamy słowo taboret i nasz p to będzie 3 słowo wyświetlane będzie brzmiało boret.);
${TEKST:p:l} - podciąg rozpoczynający się od znaku o indeksie p, a długości l ( jężeli w słowie taboret p wynosi 3 a l 2 to słowo wyświetlane brzmi bor.);
${TEKST/w/z} - zamienia tekst pasujący do "w" na tekst "z" (nie rozumiem) 

---------------------------------------------------------------------------------------
| Ćwiczenie 5a
|
| #!/bin/bash
|
|
| echo "$1  ma kota, a kot ma" $1 | sed s/a$/ę/g | sed 's/\([^ę]\)$/\1a/g'
|
| Ćwiczenie 5b
|
| #!/bin/bash
|
| zmienna=$1
| x=${#zmienna}
| echo "Pierwszy argument danego tekstu to:" ${zmienna:0:1}
| echo "Ostatni argument danego tekstu to:" ${zmienna:$((x-1)):1}
| echo -e "\e[32mSOP\e[0m"
|
---------------------------------------------------------------------------------------

Wyrażenie regularne – wzorzec opisujący łańcuch symboli. Teoria wyrażeń regularnych jest związana z teorią języków regularnych.
				   Wyrażenia regularne mogą określać zbiór pasujących łańcuchów, jak również wyszczególniać istotne części łańcucha.

W informatyce teoretycznej wyrażenia regularne są ciągami znaków pozwalającymi opisywać języki regularne.
 W praktyce znalazły bardzo szerokie zastosowanie, pozwalają bowiem w łatwy sposób opisywać wzorce tekstu, 
natomiast istniejące algorytmy w efektywny sposób określają, czy podany ciąg znaków pasuje do wzorca lub wyszukują w tekście wystąpienia wzorca. (Wikipedia)

Sed - to narzędzie uniksowe, które analizuje i przekształca tekst, używając prostego, kompaktowego języka programowania.


\[…\] <- w miejsce … wchodzi lista znaków które mogą wystąpić na danym miejscu
() <---- zbiór opcji
^ <----- początek ciągu znaków (jeśli nie występuje wewnątrz nawiasów kwadratowych)
[^] <--- wewnątrz nawiasów kwadratowych to negacja tego co w nawiasie
$ <----- koniec ciągu znaków
* <----- wzorzec tuż przed tym znakiem ma się powtarzać dowolną liczbę razy (od 0 do nieskończoności)
+ <----- wzorzec tuż przed tym znakiem ma się powtarzać co najmniej raz
. <----- dowolny jeden znak
…-… <--- zakres znaków np. [a-z]
\ <----- znak modyfikacji (escape character)       (Kopia z prezentacji) 
