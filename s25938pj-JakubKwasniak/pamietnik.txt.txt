5.03.2022

Mój kochany pamiętniczku na dzisiejszych zajęciach nauczyłem  się instalować Debiana na maszynie wirtualnej VirtualBox . Poniżej opisuje ci instrukcje 
na temat całej instalacji tego systemu.

Wpierw w Globalnych Ustawieniach ustawiamy lokalizację folderu gdzie mają się znajdować nasze maszyny
Klikamy niebieską ikonkę Nowa
Wypisujemy nazwe naszego systemu (Powinien się automatycznie ustawić Typ)
Wybieramy rozmiar pamięci RAM jaki chcemy wykorzystywać w naszej maszynie
Mamy 3 możliwości w zakładce "Dysk Twardy"

-Nie dodawaj wirtualnego dysku twardego - 
-Stwórz wirtualny dysk twardy - Przechodzimy przez dalszą konfigurację gdzie konfigurujemy parametry wirtualnego dysku (KLIKAMY W TĄ OPCJE)
-Użyj istniejącego pliku wirtualnego dysku twardego - Możemy skorzystać gdy mieliśmy już utworzoną maszynę i chcemy skorzystać ze starego wirtualnego dysku(plik vdi)

Po wybraniu drugiej opcji mamy kolejne 3 opcję z różnymi typami plików 

VDI - Standardowane natywne rozwiązanie VirtualBoxa (najlepiej działa na takowej maszynie i tą opcje wybieramy)
VHD - Rozwiązanie firmy Microsoft przeznaczony na maszyny HyperV
VMDK - Rozwiązanie Firmy VMware przeznaczone na maszymy VMware Workstation Player

Następnie mamy dwie możliwości przypisania pamięci

-Dynamiczny Rozmiar - Ustawiamy rozmiar do którego maksymalnie będzie się mógł zwiększać nasz wirtualny dysk (Wybieramy tą opcję)
-Stały Rozmiar - Wielkość zostanie natychmiast zarezerwowana dla naszego wirtualnego dysku (nie trzeba później prealokować)
Stały rozmiar jest zalecany w przypadku maszyn do celów produkcyjnych, kiedy zależy nam na jak największej wydajności

Zapisujemy ustawienia i możemu już uruchomić naszą maszynę.
Po najechaniu na strzałkę obok przycisku Uruchom mamy 3 opcję

-Zwykły start - Maszyna startuje domyślnie (w tle + okno a po zamknięciu okna zamyka się również cała maszyna)
-Bezgłowy start - Maszyna odpala się w tle ale nie wyskakuje okno (Można wykorzystać naprzykład przy Zwirtualizowanych serwerach)
-Oddzielny start - Maszyna odpala się również w tle i oknie, natomiast po zamknięciu okna(Maszyna/Odłącz interfejs graficzny) Maszyna działa dalej 

Wchodzimy w Ustawienia naszej maszyny 

W zakładce Pamięć klikamy "Dodaj napęd optyczny". Klikamy dodaj i wybieramy nasz pobrany obraz nośnika ze strony debian.org aby go potem zbootować
W zakładce Dźwięk wyłaczamy wyjście Aurdio (odznaczamy Enable Audio Output, ponieważ dźwięk nie będzie nam potrzebny w procesie instalacji systemu)
W zakładce System w "Kolejność Bootowania" Odznaczamy Floopy( ponieważ nie będziemy używać napędu dyskietek).

Odznaczanie/Usuwanie urządzeń jest zalecane w przypadku kiedy nie mamy urządzenia (jak naprzykład stacja dyskietek) i wiemy że napewno nie będziemy z 
tego korzystać w przyszłości 

Po odpaleniu maszyny i kliknięciu myszką wyskakuje okno czy chcemy aby maszyna przechwyciła naszą myszkę (Po zaakceptowaniu jeśli chcemy poruszać myszką po systemie naszego fizycznego komputera należy nacisnąć prawy CTRL)
Klikamy Right CTRL + R(Resetowanie maszyny) a następnie F12(Boot Menu). Wybieramy bootowanie naszego wirtualnego dysku (Opcja 1)

Po zbootowaniu naszego Pliku Iso Mamy 5 opcji. Jeśli chcemy wrócić do poprzedniej strony to należy najechać strzałkami na "back" lub kliknąć "esc" (Należy uważać w przypadku drugiej opcji bo może się nam zrestartować maszyna)

- Graphical install - dla 6 latków (instalacja poprzez interfejs graficzny)
- Install - instalacja tekstowa (TO WYBIERAMY)

Wybieramy instlalację tekstową z kilku powodów:

1. Prawdziwy inżynier instaluje tekstowo aby mieć większe możliwości instalacji
2. Tak jak wcześniej wspomniane instalacja graficzna jest dla osób poniżej 6 roku życia
3. Instalacja tekstowa działa szybciuej, ponieważ nie zawiera grafiki lecz sam tekst

- Advanced Option - Zaawansowane ustawienia 
	- Graphical expert install - Graficzna ekspercka instalacja
	- Graphical rescue mod - Graficzny tryb odzyskiwania 
	- Graphical automated install - Graficzna zautomatyzowana instalacja
	- Expert install - Ekspercka instalacja tekstowa

Instalacja ekspercka różni się od zwykłej tym, że mamy w niej więcej możliwości skonfigurowania naszego systemu
Należy ją stosować w wypadku kiedy wiemy co poustawiać i zależy nam na szerszej konfiguracji. Nie powinniśmy się
nią bawić kiedy nie jesteśmy pewni tego co robimy

	- Rescue mode - Tryb odzyskiwania tekstowy

https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/4/html/system_administration_guide/s1-rescuemode-boot
Rescue mod zapewnia nam uruchomienie małego środowiska Linux z napędu CD lub innej metody rozruchu poza dyskiem twardym
Tryb ten jest używany do odzyskania plików z naszego systemu, kiedy nie jesteśmy w stanie go uruchomić
Jest on używany do powyższego przykładu (Gdy chcemy odzyskać pliki z niedziałającego systemu)

	- Automated install -	Zautomatyzowana instalacja tekstowa
	- Speech-enable advanced option - Zaawansowane ustawienia syntezatora mowy
		-Expert speech install - ekspercka instalacja tekstowa z syntezatorem
		-Rescue speech mode - Tryb odzyskiwania tekstowy z syntezatorem.
		-Rescue speech install - Instalacja trybu odzyskiwania tekstowego z syntezatorem
- Accesible dark contrast installer menu - Instalacja menu ciemnego kontrastu
- Help - Wyświetla nam się ekran pomocy do instalacji systemu .
- Install with speech synthesis - instalacja z syntezatorem mowy.

Następnie wybieramy język instalacji (Angielski)

Wybieramy ten język, ponieważ w przypadku wybrania języka polskiego (w którym występują litery ą,ę,ć, itp.) Gdy jakiś program 
nie będzie posiadał tłumaczenia na dany język, mogą się nam pojawiać "⬜︎", a jak wiadomo język angielski jest powszechnie używany w IT 

Wybieramy naszą lokalizację (Other/Europe/Poland)
Wybieramy tryb kodowania znaków (z racji wybrania angielskiego wybieramy United States)
Wybieramy mape klawiszy których będziemy używać (American English)

Wybieramy ten układ z racji wybrania przez nas języka angielskiego (nie będziemy używać żadnych liter, poza tymi z alfabetu angielskiego)

---Okno instalacji---
Ustawiamy nazwę naszego komputera/hosta pod jaką będziemy widziani w sieci
Ustawiamy nazwę naszej domeny
Ustawiamy hasłe do roota (Administratora o najwyższych uprawnieniach)
Wpisujemy imię i nazwisko nowego użytkownika
Wpisujemy login nowego użytkownika
Ustawiamy hasło nowego użytkownika
---Okno instalacji---
Wyskakuje okno partycjonowania dysków
- Guided-use entire disk - Przypisywanie 1 partycji na całym dysku
- Guided-use entire disk and set up LVM - Przypisywanie 1 partycji na całym dysku i ustawienie LVM 
	(LVM-softwareowa implementacja RAIDA( WIĘCEJ INFORMACJI O RAIDZIE NA SAMYM DOLE))
- Guided-use entire disk and set up encrypted LVM - Przypisywanie 1 partycji na całym dysku i ustawienie szyfrowanego LVM
-Manual - Ręczne partycjonowanie dysków (wybieramy tą opcje)

Następnie wyskakuje 5 opcji 

-Guided partitioning - partycjonowanie dysków z "przewodnikiem/pomocą"
-Configure ISCII volumes - Konfiguracja woluminów ISCII (ISCII - schemat kodowania reprezentujący różne systemy pisma w Indiach)
-Następnie wyskakują nam nasze wszystkie partycje dysków(KLIKAMY W NASZ DYSK)
-Undo changes to partition - Cofanie zmian partycjonowania
-Finish partitioning and write changes to disk - Kończenie partycjonowania i zapisywanie zmian na dysku

Wyskakuje okno czy chcemy stworzyć nową pustą partycję na naszym urządzeniu (KLIKAMY YES)

Wyskakują poza wcześniejszymi opjcami 3 nowe
-Configure Software Raid - Konfiguracja RAID-a
-Configure the Logical Volume Manager - Konfiguracja Menedżera woluminów logicznych
-Configure encrypted manager - Konfiguracja menadżera Szyfrowania
Wybieramy zakładkę z wolnym miejscem na naszej partycji

Wyskakują 3 opjce

-Create a new partition - Tworzenie nowej partycji(WYBIERAMY TĄ OPCJE)
-Automatically partition the free space - Automatyczne tworzeniej partycji na wolnym miejscu
- Show Cylinder/Head/Selector Information - Pokazuje nam wszelkie informację na temat naszeych dysków (Cylindry, Głowice)

Ustawiamy partycję podstawową o pojemności o 8GB Mniejszą od tej pamięci jaka nam wyskakuje (Aby mieć miejsce potem na logiczną), ustawiamy ją na początku (Beginning)

Potem mamy pokazane wszystkie ustawienia naszej partycji (Możemy zmienić opcję jak możemy używać dysku(Zmienimy przy drugije partycji))

-Use as - używaj jako (domyślnie system plików ext4)
-Mount point - punkt montowania(/)
-mount options - opcje montowania(defaults-domyślne)
-Label - etykieta (none)
-Reserved blocks - Zarezerwowane bloki(5%)
-Typical usage - typowe zastosowanie (standard)
-Bootable flag - flaga startowa (off)
-Delete the partition - Usunięcie partycji
-Done setting up the partition - zatwierdzenie ustawień partycji (Klikamy to)

Mamy już utworzoną pierwszą partycję podstawową . Klikamy znowu w zakładkę free space/create a new partition/przypisujemy 8GB i ustawiamy partycję tym razem na logiczną
Wszystkie ustawienia są takie same, natomiast wchodzimy teraz w zakładkę "Use As" i mamy:

Ext4 journaling file system - Następca ext3. Obecnie najpopularniejszy system plików dla systemów Linuxa.
Ext3 journaling file system - system plików oparty na ext2. Domyśdlny dla większości systemów Linux (na jądrze od 2.4 do 2.6)
Ext2 file system - drugi rozszerzony system plików dla systemu Linux. Rozpoznanie uszkoczeń systemu następuje podczas startu. 
btrfs journaling file system - system plików copy-to-copy w stylu logowania. Zamiast zapisywać od razu w bloku są one najpierw tworzone w nowej lokalizacji, a następnie łączy się je.
JFS journaling file system - 64bitowy system plików z księgowaniem opracowany przez IBM. Jest wykorzystywany w systemach AIX  
XFS journaling file system - 64bitowy system plików z księgowaniem przeznaczony głównie do systemu IRIX. Pozwala na obsługę dużych dysków twardych
FAT16 file system - system plików posługujący się 16-bitowym adresowaniem. Pierwsze komputery działąjące na systemie DOS miały architekturę 16 bitową
FAT32 file system - System plików użyty pierwszy raz w windows 95
swap area - obszar wymiany (Jest to tzw. fałszywa pamięć ram. która znajduje się na dysku. Dobrze jest mieć tyle miejsca do wymiany co faktyczna pamięć ram(Przechowuje tam wszystkie dane))(TEGO UŻYWAMY)
physical volume for encryption - fizyczny wolumin do szyfrowania
physical volume for RAID - fizyczny wolumin dla Raida
physical volume for LVM  - Fizyczny wolumin dla LVM
do not use the partition - Nie używaj partycji

Następnie zapisujemy zmiany naszego partycjonowania

---okno instalacji---

Wyskakuje okno na temat menadżera pakietów czy zchcemy przskanować inne nośniki instalacyjne(klikamy nie)
Wybieramy skąd chcemy pobrać (z serwerów jakiego kraju) lustrzaną kopię Debiana. Wybieramy Poland a następnie serwer FTP z którego chcemy pobrać (ftp.task.gda.pl)
Wybieramy ten, ponieważ znajdujemy się w Gdańsku (W przypadku instalacji z innego miejsca, należy wybrać inny serwer, aby prędkość pobierania była zadowalająca)
Ustawiamy serwer proxy (w naszym przypadku nic nie wpisujemy) 
Ponieważ jesteśmy połączeni do routera końcowego bez żadnego pośredniczącego (którym jest właśnie serwer proxy)
Działa on na zasadzie wysyłania przez użytkownika żądania wykonania operacji do serwera , a serwer w naszym imieniu wysyła żądanie do końcowego serwera 
Wyskakuje okno czy chcemy wziąć udział w ankiecie użytkowania pakietów(klikamy nie)
Serwer ten daje nam większą anonimowość w sieci (możliwość zmiany IP) co daje nam również możliwość przeglądania witryn/zasobów niedostępnych na terenie naszego kraju
Dodatkowo daje nam możliwośc blokowania niektórych adresów internetowych, co jest przydatne w szkołach/miejscach pracy, aby uczniowie/pracownicy nie korzystali z facebooka


---Skanowanie---

Następnie wyskakuje tzw "TASK SEL". Wybieramy w nim jakie oprogramowanie chcemy dodatkowo zainstalować. Opcje jakie wyskakują to :

-GNOME
-Xfce - środowisko graficzne dla systemów uniksowych
-Gnome Flashback - Kolejne środowisko graficzne dla użytkowników którzy nie lubią unity.
-KDE Plasma - Środowisko graficzne dla systemów operacyjnych Linux. Zawiera bogaty system bibliotek do tworzenia aplikacji w środowisku graficznym
-Cinnamon - Środowisko graficzne oparte na bibliotece GTK+3
-MATE - Środowisko które powstało po krytyce na środowisko Gnome. Jego zaletami jest to, że działa w trybie 2D oraz posiada mniejsze sprzętowe wymagania
-LXDE - (Lightweight X11 Desktop Environment) - Środowisko dla systemów operacyjnych Linux
-LXQt - Środowisko graficzne połączone z dwóch projektów (LXDE-QT i Razor-qt)
-web server - Oprogramowanie umożliwiające nam postawienie serwera internetowego na naszej wirtualnej maszynie
-SSH server - Instalacja protokołu komunikacyjnego służącego w Sieciach TCP/IP. Służy między innymi do zdalnego łączenia się terminalowego z komputerami
-standard systemu utilities - Instalacja standardowych narzędzi systemowych(poniżej lista programów/pakietów które ta opcja zawiera)

https://csmojo.com/posts/what-debian-standard-system-utilities-include.html
•	apt-listchanges
•	lsof
•	zlokalizuj
•	w3m
•	w
•	libswitch-perl
•	xz-utils
•	telnet
•	dc
•	bsd-mailx
•	plik
•	exim4-config
•	m4
•	pne
•	dnsutils
•	exim4
•	Python2.7
•	opensh-klient
•	uzdolnienie
•	bash-ukończenie
•	pyton
•	gospodarz
•	informacje o instalacji
•	bzip2
•	Zgłoś błąd
•	lokale-krb5
•	bind9-host
•	czas
•	informacje
•	liblockfile-bin
•	kto jest
•	aptitude-wspólny
•	skrawek
•	ncurses-term
•	błazen
•	obsługa mimu
•	exim4-demon-światło
•	ftp
•	nfs-wspólny
•	python-zgłoś błąd
•	rpcbind
•	texinfo
•	Python-minimal
•	procmail
•	libclass-isa-perl
•	python-apt
•	Wsparcie Pythona
•	exim4-base
•	debian-faq
•	dokumentacja-debian



System bez środowiska graficznego będzie zdatny do użytku bez tej grupy pakietów, ponieważ możemy je później na spokojnie zainstalować za pomocą komendy apt install

Po wybraniu naszego oprogragmowania wyskakuje nam okno chcemy na naszej głównej partycji zainstalować GRUB boot loader
Jest to program rozruchowy rozwijany w ramach projektu GNU(mającego na celu stworzenie wolnego i kompletnego systemu uniksopodobnego)(KLIKAMY TAK)
Następnie wybieramy na jakim dysku chcemy zainstalować naszego GRUB-a

---Okno instalacji---

Następnie wyskakuje nam okno o zakończeniu instalacji. Klikamy Continue, maszyna się resetuje i cieszymy się naszym zainstalowanym systemem

----------------------------------------------------------------------------------------------------------------------------------------------

Bootloader(program rozruchowy) służy do uruchamiania różnych systemów operacyjnych.
Jest on niezbędny do działania naszego systemu, aby ten się załadował
Nie możemy go nie zainstalować, ponieważ wtedy nasz system się nie załaduje
Powinniśmy zainstalować GRUB-a :
Jeśli mamy 1 system to na tej samej partycji;
Jeśli mamy 2 systemy to wydzielić partycję boot i tam go zainstalować
W przypadku ustawienia flagi bootującej nasz GRUB będzie wiedział którą partycję ma bootować (jeśli mamy 1 system i 1 partycję, to nie ma potrzeby ustawiania flagi)

Alternatywy dla GRUB-a to:	(https://progsoft.net/pl/software/grub)

•	rEFInd
•	GRUB4DOS and WINGRUB
•	Grub2Win
•	coreboot
•	Visual BCD Editor
•	Libreboot
•	Chameleon Bootloader
•	rEFIt
•	BootIt Bare Metal
•	burg
•	DualBootPRO
•	Extended Operating System Loader
•	gummiboot
•	bootcfg
•	Gag
•	OSL2000 Boot Manager
•	Chimera
•	Linux Loader
•	Partita 2000
•	Yaboot
•	petitboot

Zalecaną strukturą partycji w naszym systemie jest:

/home
/var
/boot
/swap
/user

Rodzaje Raid:

RAID0 (tzw. Stripe) - Dane są zapisywane naprzemiennie na dwóch dyskach. Daje to nam większe prędkości odczytu i zapisu. W przypadku awarii tracimy wszystkie dane
RAID1 (tzw. Mirroring) - Na jednym dysku są zapisywane dane, a na drugim ich kopia . Dzięki temu w przypadku awarii nie tracimy danych, natomiast tracimy 50% pojemności (gdy mamy 2x10TB to pamięć użytkowa wynosi 10TB)
RAID10 - Połączenie Raid0 i Raid1 . Na dwóch dyskach są zapisywane naprzemiennie dane a na pozostałych dwóch są zapisywane ich lustrzane kopie . Jeśli uszkodzeniu ulegnie dysk + dysk z kopią to tracimy dane.
RAID4 - Dane są zapisywane na kilku dyskach, a na osobnym są umieszczane sumy kontrolne, które w przypadku uszkodzenia danych dają nam możliwość odtworzenia danych poprzez wykonanie operacji matematycznych.
RAID5 - Działa na takiej samej zasadzie jak RAID4, natomiast sumy kontrolne nie są rozmieszczone na osobnym dysku, ale na są rozłożone na wszystkie dysku. Jego słabe strony, to że po awari macierz musi odbudować
sumy kontrolne, co obciąża mocno syste, a w przypadku gdy chcemy dodać dodatkowy dysk to cała macierz musi zostać przebudowana 
RAID DP - Raid opatentowany przez firmę NetApp. Charakteryzuje się odpornością na awarię 2 dysków (Działa na zasadzie RAID4, natomiast różni się tym, że sumy kontrolne są rozmieszczone na 2 dyskach)

Docker - Mała maszyna wirtualna z 1 procesem mająca niski narzut.

Co możemy znaleźć na podstronie "Jak zdobyć Debiana" (https://www.debian.org/distrib/)
Mamy tam różne rozwiązania jak możemy zdobyć i zainstalować nasz system

Pierwsza opcja to pobranie zwykłego pliku ISO (mamy szeroką listę architektur dla procesorów)
Jest to podzielone na mały plik obrazu który zajmuje mniej miejsca i jest bardziej okrojony (Potrzebne jest połączenie z internetem)
Druga opcja to kompletny plik obrazu, co daje nam więcej pakietów i możliwość instalacji bez połączenia internetowego

Druga opcja to "Użyj obrazu Debiana dla chmury". Jest to rozwiązanie pozwalające zainstalować nasz system w chmurach u takich dostawców jak:
Amazon EC2, Microsoft Azure, OpenStack lub zwykła maszyna wirtualna

Trzecia opcja pozwala nam kupić płyty z systemem Debian od różnych sprzedawców. Po kliknięciu w odnośnik przenosimy się na pełną listę z wypisanymi
Sprzedawcami z różnych krajów (Na stronie nie zauważymy żadnego sprzedawcy z Polski)

Czwarta opjca daje nan możliwość pobrania i zainstalowania systemu w wersji "portable". Wystarczy zainstalować go na dowolnym pendrive/przenośnym dysku 
i odpalić go na każdym urządzeniu . Wystarczy podłączyć pendrive i zbootować go w boot menu

Ostatnia opcja to kupno komputera z już zainstalowanym Debianem. Minusem tego rozwiązania jest to, że płacimy za system który jest tak naprawdę darmowy.
Plusem natomiast jest wstępna konfiguracja systemu która jest dopasowana do naszego sprzętu oraz sprzedawca może nam zaoferować pomoc techniczną.

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

19.03.2022
 
Drogi pamiętniczku

Na dzisiejszych ćwiczeniach rozmawialiśmy o pisaniu skryptów i omawialiśmy czym tak właściwie jest bash
Bash jest powłoką systemową (Łącznikiem pomiędzy komputerem(maszyną) a użytkownikiem), która
pozwala na komunikację w trybie tekstowym. Jest powłoką napisaną typowo pod Linuxa(Na Windowsie mamy coś takiego jak PowerShell).
Skrypty – programy napisane w językach skryptowych, przeznaczone do wykonywania w specjalnych środowiskach uruchomieniowych automatyzujących wykonywanie zadań, które alternatywnie mogą być wykonywane jedno po drugim przez użytkownika.(Wikipedia).
W uproszczeniu skrypt jest plikiem tekstowym z instrukcją algorytmu jaki ma zostać wykonany.

Omawialiśmy podstawy skryptowania w Bashu.Żeby móc pisać skrypty w tej oto powłoce należy sciągnąć jakiś interpreter(git bash, cmder),
Następnie możemy użyć albo maszyny wirtualnej z zainstalowanym systemem spod stajni Linuxa (Debian,Ubuntu,Kali itp.) lub możemy skorzystać z serwera szkolnego "Szuflandia" którego używaliśmy na zajęciach.
Aby połączyć się z naszym serwerem należy użyć programu klienckiego SSH (może być to PUTTY, który jest najpopularniejszy). W polu hostname or ip adress wpisujemy nasz_indeks@szuflandia.pjwstk.edu.pl
Po połączeniu się z naszym serwerem wpisujemy hasło do konta i mamy dostęp do serwera.

Następnie aby napisać nasz skrypt należy użyć jakiegoś edytora tekstu w terminalu (Nano który jest dużo prostszy w obsłudze, lub vim który jest bardziej zaawansowany, przez co daje nam
dużo większe możliwości podczas pisania naszego skryptu(m.in. może on kolorować naszą składnię))

W pierwszej lini (tzw. shebang (#!/bin/bash)) definiujemy z jakiego interpretera nasz skrypt ma korzystać.
Jeśli napiszemy skrypt w bashu a nie zdefiniujemy shebanga, to nic się nie stanie, ponieważ skrypt domyślnie odpala się w interpreterze bash
Jeśli natomiast napiszemy skrypt w innym języku (java, c++, c, python) to nasz interpreter nie uruchomi skryptu i będzie trzeba zdefinować shebang-a

Piszemy  pierwszy skrypt (Piszemy go narazie w nano, ponieważ nie umiemy jeszcze korzystać z Vim-a):


#!/bin/bash

# Skrypt wykorzystuje zaawansowane funkcje  - po znaku # możemy pisać komentarze (interpreter tego nie widzi)
# systemu do tego, aby narysować króliczka:
echo -e "    \e[m(\\_/)"
echo -e "   (=\e[33m'\e[31m.\e[33m'\e[0m=)"
Na końcu każdego skrypu musimy wcisnąć ENTER, ponieważ nasz interpreter nie przeczyta ostatniej linii.

Po wciśnięciu F2 nasz edytor zapyta czy chcemy zapisać bufor, wciskamy tak i nadajemy nazwe swojego pliku (kroliczek.sh - na końcu musi byc .sh dzięki czemu nasz interpreter będzie wiedział
że zapisany plik jest skryptem a nie zwykłym plikiem tekstowym).
  
Teraz uruchamiamy nasz skrypt.
Aby to zrobić musimy wpisać "./kroliczek.sh".
W konsoli zamiast królika wyskakuję błąd o braku dostępu.Jest to spowodowane tym, że nie nadaliśmy skryptowi bitu wykonywalności.
Aby go nadać używamy komendy chmod ./kroliczek.sh 
Możemy natomiast do odpalenia naszego skryptu użyć innego sposobu.Jest możliwość odpalenia skryptu bez nadawania upranień robi się to w następujący sposób: bash kroliczek.sh.
Teraz nasz skrypt wydrukuje nam w konsoli naszego królika.
  
    (\_/)
   (='.'=)

*Różnica między prawami, a uprawnieniamy*
W Linuxie możemy nadawać tylko uprawnienia, natomiast w Windowsie mamy zarówno prawa, jak i uprawnienia.

Mówiliśmy również zmiennych powłokach.
Zmienna powłoka służy do przechowywania wartości.Działa to na podobnej zasadzie jak w przypadku programowania. 
Jest zmienna którą musimy nazwać, określić jej typ (Mamy zarówno zmienne lokalne, jak i zmienne globalne).
Tak samo jak w językach programowania, aby przypisać jakąś wartość do zmiennej musimy ją nazwać używając znaku "równa się"(=)
Nie musimy natomiast deklarować typu naszej zmiennej, ponieważ system robi to automatycznie.

ZM=moja_zmienna

Mamy 3 sposoby na nazwanie naszej zmiennej:

-Wpisujemy poprostu nazwę nasszej zmiennej tak jak powyżej(NIE MOŻNA UŻYWAĆ SPACJI);
-w cudzysłowiach "" (jeśli będziemy mieli jakieś znaki specjalne interpreter przeczyta to jako wartości);
-w apostrofach '' (możemy napisać co nam się podoba. Interpreter przeczyta to po prostu jako napis);

*Nie używa się source'owania w uruchamianiu skryptu, ponieważ może to nadpisać naszą funkcje. Używa się go do doładowania funkcji.*
Aby usunąć naszą funkcję używamy komendy "unset", czyli unset <nazwa_zmiennej>.
Żeby wyświetlić naszą zmienną używamy następującej komendy: 
echo $ZM,(konsola wyświetli nam to co przypisaliśmy do "ZM", czyli napis "moja_zmienna").
Dolara przed zmienną podajemy wtedy kiedy interesuje nas jej wartość.

-unset ZM - Komenda usunie nam "całość" naszej zmiennej 
-echo $ZM - Komenda wyświetli wartość naszej zmiennej 

Dziedziczenie:

Jak już pisaliśmy zmienne mogą być zarówno lokalne (dostępne tylko w 1 powłoce) lub globalne (dostępne z poziomu każdej powłoki).
Przy przypisaniu wartości danej zmiennej (np. zm=3) ustawiamy wartość tej zmiennej  globalnie. Jeśli chcemy natomiast przypisać jej wartość lokalnie możemy to zrobić w dwa poniższe sposoby: 

-Tworzymy zmienną a następnie za pomocą komendy export przypisujemy ją do powłoki jakiej chcemy :
ZM=3
export ZM
-Tworzymy zmienną i od razu przypisujemy ją do powłoki jakiej chcemy:
export ZM=3

*Poruszanie się po powłokach jest możliwe za pomocą dwóch komend:
bash - skaczemy na kolejną powłoke
exit - cofamy się na poprzednią

do usuwania exportowanych wartości istnieją dwa sposoby:
-export -n zm - (na powłoce, na której powstała nasza zmienna komenda ta powoduje usunięcie wartości na wszystkich powłokach oprócz aktualnej).
-unset zm - komenda ta usuwa zmienną we wszystkich powłokach oraz aktualnej (jeśli usuniemy ją na innej powłoce to nie usunie się ona na pozostałych)

Odczytywanie zmiennych odbywa się na dwa sposoby:
-$Zmienna
-${Zmienna} - Przydaje się przy kontatenacja (Łączeniu napisów)

Do zmiennej można przypisać wywołanie komendy np:

-ZM=$(echo witaj) - Starszy sposób (wolniejszy, natomiast jego plusem jest to że działa na wszystkich wersjach); 
-ZM='echo witaj' -  Nowy sposób (Szybszy z krótszą składnia, natomiast nie działa na wszystkich wersjach);

Reasumując obie te komendy robią to samo (przypisują do wartości zmiennej jakąs komende)
potem po wpisaniu echo $ZM konsola wypisze nam nasz napis w dwóch przypadkach.

Bash oferuje nam również operację na ciągach znaków, za pomocą (( )), możemy  dokonywać prostych obliczeń np:
                 _______________
                |-echo $((2+2)) |
                |wyświetla 4    |
                |-X=5 		  |
                |echo $((2*X))  |
                |wyświetla 10   |
                |_______________|

Operację na ciągach znaków (PREZENTACJA):

${#TEKST} - długość ciągu znaków ( po przypisaniu tekstu do wartości TEKST);
${TEKST:p} - podciąg rozpoczynający się od znaku o indeksie p. (zamiast p wstawiamy liczbe od której nasz ciąg ma się zacząc jeżeli mamy słowo taboret i nasz p to będzie 3 słowo wyświetlane będzie brzmiało boret.);
${TEKST:p:l} - podciąg rozpoczynający się od znaku o indeksie p, a długości l ( jężeli w słowie taboret p wynosi 3 a l 2 to słowo wyświetlane brzmi bor.);
${TEKST/w/z} - zamienia tekst pasujący do "w" na tekst "z" (nie rozumiem)

Wyrażenie regularne – W uproszczeniu są to po prostu wzorce, które opisuą określony tekst do wyszukiwania. Zwykłe wyrażenia regularne 
nazywamy regex od skrótu regular expression. Są używane do wyszukiwania określonych ciągów znaków w tekstach.
Technicznie regexy są zbiorem zasad, które ciąg znaków powinien spełnić. Jeśli ciąg pasuje do regexu to mówimy że pasuje 
do wyrażenia regularnego.
Przykładami programów które korzystają z regexów są grep i less

Sed - to narzędzie uniksowe, które analizuje i przekształca tekst, używając prostego, kompaktowego języka programowania.


\[…\] - w miejsce … wchodzi lista znaków które mogą wystąpić na danym miejscu
() - zbiór opcji
^ - początek ciągu znaków (jeśli nie występuje wewnątrz nawiasów kwadratowych)
[^] - wewnątrz nawiasów kwadratowych to negacja tego co w nawiasie
$ - koniec ciągu znaków
* - wzorzec tuż przed tym znakiem ma się powtarzać dowolną liczbę razy (od 0 do nieskończoności)
+ - wzorzec tuż przed tym znakiem ma się powtarzać co najmniej raz
. - dowolny jeden znak
…-… - zakres znaków np. [a-z]
\ - znak modyfikacji (escape character)

Zmienne przydatne do pisania skryptów:
														
 $@ - Wypisuje co się pojawi po echo 
 $* - nic nie pokazuje
 $0 - wypisuje ścieżkę do skryptu
 $1,$2 - wypisuje kolejne zmienne (ich ilość zalezy od ilości zmiennych w programie
 $# - wypisuje ilość zmiennych
 $? - wypisuje "exit status"-stan wyjścia
 $$ - wypisuje ID procesu
 $! - wypisuje ID ostatniego procesu działającego w tle


														ĆWICZENIA

 Ćwiczenie 1		_______________________________________________________________________			
	 		
 #!/bin/bash				
 echo "Witamy w terminalu"	

Ćwiczenie 2			_______________________________________________________________________	

X=tekst
echo $X
bash
echo $X

Co się stało?
Otworzył się nam nowy bash/nowa powłoka po chwili ładowania.

X=Tekst dłuższy
echo $X

Aby naprawić błąd musimy naszą zmienną zapisać w ""
X="Tekst dłuższy"
echo $X
Teraz zadziała 

Ćwiczenie 3			_______________________________________________________________________

-PATH 	- Pokazuje ścieżki do komend- umożliwia dodanie skryptu do ścieżki z dowolnego miejsca export PATH(nazwa)=<ścieżka> 
-RANDOM 	- Generator losowych liczb
-PWD 		- Zmienna do używania w skryptach pokazuje ściezke w skrypcie
-PS1		- Wyświetla wartości konsoli
-USER 	- Wyświetlanie naszego loginu
-HOSTNAME 	- Wyświetlanie nazwe naszego hosta
-OSTYPE 	- Wyświetla wersje naszego systemu operacyjnego


Ćwiczenie 4__________________________________________________________

zmienn1a=$(ls -la) 
echo $zmienna1 

Nie dostaniemy wyniku ls-la
Wywołanie naszej zmiennej da nam natycmiastowo komendę ls -la(wyświetlenie zawartości ścieżki z ukrytymi plikami) oraz z informacjami na temat dostępów 
Nie wypsiuje informacji w liniach tylko jednym ciągiem

zmienna2=$(ls -l) 
echo $zmienna2

jak wyżej opisane


 Ćwiczenie 5a_______________________________________________________________

A=Ala
echo $A ma kota, a kot ma ${A}ę
Wypisuje Ala ma kota, kot ma Alaę


 Ćwiczenie 5b_______________________________________________________________

 #!/bin/bash

 zmienna=$1
 x=${#arg}
 echo "Pierwszy znak z argumentu:" ${arg:0:1}
 echo "Ostatni znak z argumentu:" ${arg:$((x-1)):1}
 echo -e "\e[32mSOP\e[0m"


 Ćwiczenie 6_______________________________________________________________

 #!/bin/bash
 echo "$1  ma kota, a kot ma" $1 | sed s/a$/ę/g | sed 's/\([^ę]\)$/\1a/g'

Praca Domowa

#!/bin/bash
x=$(cat $1)
z=$(echo $x | sed 's/\Jakub\>/\\e[31mJakub\\e[0m/g')
echo -e "$z"